{"ast":null,"code":"// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () {\n  return false;\n};\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr ? 'calc' : ['', '-webkit-', '-moz-', '-o-'].filter(function (prefix) {\n  var el = document.createElement('div');\n  el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n  return !!el.style.length;\n}).shift() + \"calc\";\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) {\n  return typeof v === 'string' || v instanceof String;\n};\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n  if (isString(el)) {\n    var ele = document.querySelector(el);\n    if (!ele) {\n      throw new Error(\"Selector \" + el + \" did not match a DOM element\");\n    }\n    return ele;\n  }\n  return el;\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n  var value = options[propName];\n  if (value !== undefined) {\n    return value;\n  }\n  return def;\n};\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n  if (isFirst) {\n    if (gutterAlign === 'end') {\n      return 0;\n    }\n    if (gutterAlign === 'center') {\n      return gutterSize / 2;\n    }\n  } else if (isLast) {\n    if (gutterAlign === 'start') {\n      return 0;\n    }\n    if (gutterAlign === 'center') {\n      return gutterSize / 2;\n    }\n  }\n  return gutterSize;\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n  var gut = document.createElement('div');\n  gut.className = \"gutter gutter-\" + gutterDirection;\n  return gut;\n};\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n  var style = {};\n  if (!isString(size)) {\n    style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n  } else {\n    style[dim] = size;\n  }\n  return style;\n};\nvar defaultGutterStyleFn = function (dim, gutSize) {\n  var obj;\n  return obj = {}, obj[dim] = gutSize + \"px\", obj;\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n  if (options === void 0) options = {};\n  if (ssr) {\n    return {};\n  }\n  var ids = idsOption;\n  var dimension;\n  var clientAxis;\n  var position;\n  var positionEnd;\n  var clientSize;\n  var elements;\n\n  // Allow HTMLCollection to be used as an argument when supported\n  if (Array.from) {\n    ids = Array.from(ids);\n  }\n\n  // All DOM elements in the split should have a common parent. We can grab\n  // the first elements parent and hope users read the docs because the\n  // behavior will be whacky otherwise.\n  var firstElement = elementOrSelector(ids[0]);\n  var parent = firstElement.parentNode;\n  var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n  var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n  // Set default options.sizes to equal percentages of the parent element.\n  var sizes = getOption(options, 'sizes') || ids.map(function () {\n    return 100 / ids.length;\n  });\n\n  // Standardize minSize and maxSize to an array if it isn't already.\n  // This allows minSize and maxSize to be passed as a number.\n  var minSize = getOption(options, 'minSize', 100);\n  var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () {\n    return minSize;\n  });\n  var maxSize = getOption(options, 'maxSize', Infinity);\n  var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () {\n    return maxSize;\n  });\n\n  // Get other options\n  var expandToMin = getOption(options, 'expandToMin', false);\n  var gutterSize = getOption(options, 'gutterSize', 10);\n  var gutterAlign = getOption(options, 'gutterAlign', 'center');\n  var snapOffset = getOption(options, 'snapOffset', 30);\n  var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () {\n    return snapOffset;\n  });\n  var dragInterval = getOption(options, 'dragInterval', 1);\n  var direction = getOption(options, 'direction', HORIZONTAL);\n  var cursor = getOption(options, 'cursor', direction === HORIZONTAL ? 'col-resize' : 'row-resize');\n  var gutter = getOption(options, 'gutter', defaultGutterFn);\n  var elementStyle = getOption(options, 'elementStyle', defaultElementStyleFn);\n  var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n  // 2. Initialize a bunch of strings based on the direction we're splitting.\n  // A lot of the behavior in the rest of the library is paramatized down to\n  // rely on CSS strings and classes.\n  if (direction === HORIZONTAL) {\n    dimension = 'width';\n    clientAxis = 'clientX';\n    position = 'left';\n    positionEnd = 'right';\n    clientSize = 'clientWidth';\n  } else if (direction === 'vertical') {\n    dimension = 'height';\n    clientAxis = 'clientY';\n    position = 'top';\n    positionEnd = 'bottom';\n    clientSize = 'clientHeight';\n  }\n\n  // 3. Define the dragging helper functions, and a few helpers to go with them.\n  // Each helper is bound to a pair object that contains its metadata. This\n  // also makes it easy to store references to listeners that that will be\n  // added and removed.\n  //\n  // Even though there are no other functions contained in them, aliasing\n  // this to self saves 50 bytes or so since it's used so frequently.\n  //\n  // The pair object saves metadata like dragging state, position and\n  // event listener references.\n\n  function setElementSize(el, size, gutSize, i) {\n    // Split.js allows setting sizes via numbers (ideally), or if you must,\n    // by string, like '300px'. This is less than ideal, because it breaks\n    // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n    // make sure you calculate the gutter size by hand.\n    var style = elementStyle(dimension, size, gutSize, i);\n    Object.keys(style).forEach(function (prop) {\n      // eslint-disable-next-line no-param-reassign\n      el.style[prop] = style[prop];\n    });\n  }\n  function setGutterSize(gutterElement, gutSize, i) {\n    var style = gutterStyle(dimension, gutSize, i);\n    Object.keys(style).forEach(function (prop) {\n      // eslint-disable-next-line no-param-reassign\n      gutterElement.style[prop] = style[prop];\n    });\n  }\n  function getSizes() {\n    return elements.map(function (element) {\n      return element.size;\n    });\n  }\n\n  // Supports touch events, but not multitouch, so only the first\n  // finger `touches[0]` is counted.\n  function getMousePosition(e) {\n    if ('touches' in e) {\n      return e.touches[0][clientAxis];\n    }\n    return e[clientAxis];\n  }\n\n  // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n  // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n  // which allows the viewport to be resized without additional logic.\n  // Element a's size is the same as offset. b's size is total size - a size.\n  // Both sizes are calculated from the initial parent percentage,\n  // then the gutter size is subtracted.\n  function adjust(offset) {\n    var a = elements[this.a];\n    var b = elements[this.b];\n    var percentage = a.size + b.size;\n    a.size = offset / this.size * percentage;\n    b.size = percentage - offset / this.size * percentage;\n    setElementSize(a.element, a.size, this[aGutterSize], a.i);\n    setElementSize(b.element, b.size, this[bGutterSize], b.i);\n  }\n\n  // drag, where all the magic happens. The logic is really quite simple:\n  //\n  // 1. Ignore if the pair is not dragging.\n  // 2. Get the offset of the event.\n  // 3. Snap offset to min if within snappable range (within min + snapOffset).\n  // 4. Actually adjust each element in the pair to offset.\n  //\n  // ---------------------------------------------------------------------\n  // |    | <- a.minSize               ||              b.minSize -> |    |\n  // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n  // |    |  |                         ||                        |  |    |\n  // |    |  |                         ||                        |  |    |\n  // ---------------------------------------------------------------------\n  // | <- this.start                                        this.size -> |\n  function drag(e) {\n    var offset;\n    var a = elements[this.a];\n    var b = elements[this.b];\n    if (!this.dragging) {\n      return;\n    }\n\n    // Get the offset of the event from the first side of the\n    // pair `this.start`. Then offset by the initial position of the\n    // mouse compared to the gutter size.\n    offset = getMousePosition(e) - this.start + (this[aGutterSize] - this.dragOffset);\n    if (dragInterval > 1) {\n      offset = Math.round(offset / dragInterval) * dragInterval;\n    }\n\n    // If within snapOffset of min or max, set offset to min or max.\n    // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n    // Include the appropriate gutter sizes to prevent overflows.\n    if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n      offset = a.minSize + this[aGutterSize];\n    } else if (offset >= this.size - (b.minSize + b.snapOffset + this[bGutterSize])) {\n      offset = this.size - (b.minSize + this[bGutterSize]);\n    }\n    if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n      offset = a.maxSize + this[aGutterSize];\n    } else if (offset <= this.size - (b.maxSize - b.snapOffset + this[bGutterSize])) {\n      offset = this.size - (b.maxSize + this[bGutterSize]);\n    }\n\n    // Actually adjust the size.\n    adjust.call(this, offset);\n\n    // Call the drag callback continously. Don't do anything too intensive\n    // in this callback.\n    getOption(options, 'onDrag', NOOP)(getSizes());\n  }\n\n  // Cache some important sizes when drag starts, so we don't have to do that\n  // continously:\n  //\n  // `size`: The total size of the pair. First + second + first gutter + second gutter.\n  // `start`: The leading side of the first element.\n  //\n  // ------------------------------------------------\n  // |      aGutterSize -> |||                      |\n  // |                     |||                      |\n  // |                     |||                      |\n  // |                     ||| <- bGutterSize       |\n  // ------------------------------------------------\n  // | <- start                             size -> |\n  function calculateSizes() {\n    // Figure out the parent size minus padding.\n    var a = elements[this.a].element;\n    var b = elements[this.b].element;\n    var aBounds = a[getBoundingClientRect]();\n    var bBounds = b[getBoundingClientRect]();\n    this.size = aBounds[dimension] + bBounds[dimension] + this[aGutterSize] + this[bGutterSize];\n    this.start = aBounds[position];\n    this.end = aBounds[positionEnd];\n  }\n  function innerSize(element) {\n    // Return nothing if getComputedStyle is not supported (< IE9)\n    // Or if parent element has no layout yet\n    if (!getComputedStyle) {\n      return null;\n    }\n    var computedStyle = getComputedStyle(element);\n    if (!computedStyle) {\n      return null;\n    }\n    var size = element[clientSize];\n    if (size === 0) {\n      return null;\n    }\n    if (direction === HORIZONTAL) {\n      size -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n    } else {\n      size -= parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom);\n    }\n    return size;\n  }\n\n  // When specifying percentage sizes that are less than the computed\n  // size of the element minus the gutter, the lesser percentages must be increased\n  // (and decreased from the other elements) to make space for the pixels\n  // subtracted by the gutters.\n  function trimToMin(sizesToTrim) {\n    // Try to get inner size of parent element.\n    // If it's no supported, return original sizes.\n    var parentSize = innerSize(parent);\n    if (parentSize === null) {\n      return sizesToTrim;\n    }\n    if (minSizes.reduce(function (a, b) {\n      return a + b;\n    }, 0) > parentSize) {\n      return sizesToTrim;\n    }\n\n    // Keep track of the excess pixels, the amount of pixels over the desired percentage\n    // Also keep track of the elements with pixels to spare, to decrease after if needed\n    var excessPixels = 0;\n    var toSpare = [];\n    var pixelSizes = sizesToTrim.map(function (size, i) {\n      // Convert requested percentages to pixel sizes\n      var pixelSize = parentSize * size / 100;\n      var elementGutterSize = getGutterSize(gutterSize, i === 0, i === sizesToTrim.length - 1, gutterAlign);\n      var elementMinSize = minSizes[i] + elementGutterSize;\n\n      // If element is too smal, increase excess pixels by the difference\n      // and mark that it has no pixels to spare\n      if (pixelSize < elementMinSize) {\n        excessPixels += elementMinSize - pixelSize;\n        toSpare.push(0);\n        return elementMinSize;\n      }\n\n      // Otherwise, mark the pixels it has to spare and return it's original size\n      toSpare.push(pixelSize - elementMinSize);\n      return pixelSize;\n    });\n\n    // If nothing was adjusted, return the original sizes\n    if (excessPixels === 0) {\n      return sizesToTrim;\n    }\n    return pixelSizes.map(function (pixelSize, i) {\n      var newPixelSize = pixelSize;\n\n      // While there's still pixels to take, and there's enough pixels to spare,\n      // take as many as possible up to the total excess pixels\n      if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n        var takenPixels = Math.min(excessPixels, toSpare[i] - excessPixels);\n\n        // Subtract the amount taken for the next iteration\n        excessPixels -= takenPixels;\n        newPixelSize = pixelSize - takenPixels;\n      }\n\n      // Return the pixel size adjusted as a percentage\n      return newPixelSize / parentSize * 100;\n    });\n  }\n\n  // stopDragging is very similar to startDragging in reverse.\n  function stopDragging() {\n    var self = this;\n    var a = elements[self.a].element;\n    var b = elements[self.b].element;\n    if (self.dragging) {\n      getOption(options, 'onDragEnd', NOOP)(getSizes());\n    }\n    self.dragging = false;\n\n    // Remove the stored event listeners. This is why we store them.\n    global[removeEventListener]('mouseup', self.stop);\n    global[removeEventListener]('touchend', self.stop);\n    global[removeEventListener]('touchcancel', self.stop);\n    global[removeEventListener]('mousemove', self.move);\n    global[removeEventListener]('touchmove', self.move);\n\n    // Clear bound function references\n    self.stop = null;\n    self.move = null;\n    a[removeEventListener]('selectstart', NOOP);\n    a[removeEventListener]('dragstart', NOOP);\n    b[removeEventListener]('selectstart', NOOP);\n    b[removeEventListener]('dragstart', NOOP);\n    a.style.userSelect = '';\n    a.style.webkitUserSelect = '';\n    a.style.MozUserSelect = '';\n    a.style.pointerEvents = '';\n    b.style.userSelect = '';\n    b.style.webkitUserSelect = '';\n    b.style.MozUserSelect = '';\n    b.style.pointerEvents = '';\n    self.gutter.style.cursor = '';\n    self.parent.style.cursor = '';\n    document.body.style.cursor = '';\n  }\n\n  // startDragging calls `calculateSizes` to store the inital size in the pair object.\n  // It also adds event listeners for mouse/touch events,\n  // and prevents selection while dragging so avoid the selecting text.\n  function startDragging(e) {\n    // Right-clicking can't start dragging.\n    if ('button' in e && e.button !== 0) {\n      return;\n    }\n\n    // Alias frequently used variables to save space. 200 bytes.\n    var self = this;\n    var a = elements[self.a].element;\n    var b = elements[self.b].element;\n\n    // Call the onDragStart callback.\n    if (!self.dragging) {\n      getOption(options, 'onDragStart', NOOP)(getSizes());\n    }\n\n    // Don't actually drag the element. We emulate that in the drag function.\n    e.preventDefault();\n\n    // Set the dragging property of the pair object.\n    self.dragging = true;\n\n    // Create two event listeners bound to the same pair object and store\n    // them in the pair object.\n    self.move = drag.bind(self);\n    self.stop = stopDragging.bind(self);\n\n    // All the binding. `window` gets the stop events in case we drag out of the elements.\n    global[addEventListener]('mouseup', self.stop);\n    global[addEventListener]('touchend', self.stop);\n    global[addEventListener]('touchcancel', self.stop);\n    global[addEventListener]('mousemove', self.move);\n    global[addEventListener]('touchmove', self.move);\n\n    // Disable selection. Disable!\n    a[addEventListener]('selectstart', NOOP);\n    a[addEventListener]('dragstart', NOOP);\n    b[addEventListener]('selectstart', NOOP);\n    b[addEventListener]('dragstart', NOOP);\n    a.style.userSelect = 'none';\n    a.style.webkitUserSelect = 'none';\n    a.style.MozUserSelect = 'none';\n    a.style.pointerEvents = 'none';\n    b.style.userSelect = 'none';\n    b.style.webkitUserSelect = 'none';\n    b.style.MozUserSelect = 'none';\n    b.style.pointerEvents = 'none';\n\n    // Set the cursor at multiple levels\n    self.gutter.style.cursor = cursor;\n    self.parent.style.cursor = cursor;\n    document.body.style.cursor = cursor;\n\n    // Cache the initial sizes of the pair.\n    calculateSizes.call(self);\n\n    // Determine the position of the mouse compared to the gutter\n    self.dragOffset = getMousePosition(e) - self.end;\n  }\n\n  // adjust sizes to ensure percentage is within min size and gutter.\n  sizes = trimToMin(sizes);\n\n  // 5. Create pair and element objects. Each pair has an index reference to\n  // elements `a` and `b` of the pair (first and second elements).\n  // Loop through the elements while pairing them off. Every pair gets a\n  // `pair` object and a gutter.\n  //\n  // Basic logic:\n  //\n  // - Starting with the second element `i > 0`, create `pair` objects with\n  //   `a = i - 1` and `b = i`\n  // - Set gutter sizes based on the _pair_ being first/last. The first and last\n  //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n  // - Create gutter elements and add event listeners.\n  // - Set the size of the elements, minus the gutter sizes.\n  //\n  // -----------------------------------------------------------------------\n  // |     i=0     |         i=1         |        i=2       |      i=3     |\n  // |             |                     |                  |              |\n  // |           pair 0                pair 1             pair 2           |\n  // |             |                     |                  |              |\n  // -----------------------------------------------------------------------\n  var pairs = [];\n  elements = ids.map(function (id, i) {\n    // Create the element object.\n    var element = {\n      element: elementOrSelector(id),\n      size: sizes[i],\n      minSize: minSizes[i],\n      maxSize: maxSizes[i],\n      snapOffset: snapOffsets[i],\n      i: i\n    };\n    var pair;\n    if (i > 0) {\n      // Create the pair object with its metadata.\n      pair = {\n        a: i - 1,\n        b: i,\n        dragging: false,\n        direction: direction,\n        parent: parent\n      };\n      pair[aGutterSize] = getGutterSize(gutterSize, i - 1 === 0, false, gutterAlign);\n      pair[bGutterSize] = getGutterSize(gutterSize, false, i === ids.length - 1, gutterAlign);\n\n      // if the parent has a reverse flex-direction, switch the pair elements.\n      if (parentFlexDirection === 'row-reverse' || parentFlexDirection === 'column-reverse') {\n        var temp = pair.a;\n        pair.a = pair.b;\n        pair.b = temp;\n      }\n    }\n\n    // Determine the size of the current element. IE8 is supported by\n    // staticly assigning sizes without draggable gutters. Assigns a string\n    // to `size`.\n    //\n    // Create gutter elements for each pair.\n    if (i > 0) {\n      var gutterElement = gutter(i, direction, element.element);\n      setGutterSize(gutterElement, gutterSize, i);\n\n      // Save bound event listener for removal later\n      pair[gutterStartDragging] = startDragging.bind(pair);\n\n      // Attach bound event listener\n      gutterElement[addEventListener]('mousedown', pair[gutterStartDragging]);\n      gutterElement[addEventListener]('touchstart', pair[gutterStartDragging]);\n      parent.insertBefore(gutterElement, element.element);\n      pair.gutter = gutterElement;\n    }\n    setElementSize(element.element, element.size, getGutterSize(gutterSize, i === 0, i === ids.length - 1, gutterAlign), i);\n\n    // After the first iteration, and we have a pair object, append it to the\n    // list of pairs.\n    if (i > 0) {\n      pairs.push(pair);\n    }\n    return element;\n  });\n  function adjustToMin(element) {\n    var isLast = element.i === pairs.length;\n    var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n    calculateSizes.call(pair);\n    var size = isLast ? pair.size - element.minSize - pair[bGutterSize] : element.minSize + pair[aGutterSize];\n    adjust.call(pair, size);\n  }\n  elements.forEach(function (element) {\n    var computedSize = element.element[getBoundingClientRect]()[dimension];\n    if (computedSize < element.minSize) {\n      if (expandToMin) {\n        adjustToMin(element);\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        element.minSize = computedSize;\n      }\n    }\n  });\n  function setSizes(newSizes) {\n    var trimmed = trimToMin(newSizes);\n    trimmed.forEach(function (newSize, i) {\n      if (i > 0) {\n        var pair = pairs[i - 1];\n        var a = elements[pair.a];\n        var b = elements[pair.b];\n        a.size = trimmed[i - 1];\n        b.size = newSize;\n        setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n        setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n      }\n    });\n  }\n  function destroy(preserveStyles, preserveGutter) {\n    pairs.forEach(function (pair) {\n      if (preserveGutter !== true) {\n        pair.parent.removeChild(pair.gutter);\n      } else {\n        pair.gutter[removeEventListener]('mousedown', pair[gutterStartDragging]);\n        pair.gutter[removeEventListener]('touchstart', pair[gutterStartDragging]);\n      }\n      if (preserveStyles !== true) {\n        var style = elementStyle(dimension, pair.a.size, pair[aGutterSize]);\n        Object.keys(style).forEach(function (prop) {\n          elements[pair.a].element.style[prop] = '';\n          elements[pair.b].element.style[prop] = '';\n        });\n      }\n    });\n  }\n  return {\n    setSizes: setSizes,\n    getSizes: getSizes,\n    collapse: function collapse(i) {\n      adjustToMin(elements[i]);\n    },\n    destroy: destroy,\n    parent: parent,\n    pairs: pairs\n  };\n};\nexport default Split;","map":{"version":3,"names":["global","window","ssr","document","undefined","addEventListener","removeEventListener","getBoundingClientRect","gutterStartDragging","aGutterSize","bGutterSize","HORIZONTAL","NOOP","calc","filter","prefix","el","createElement","style","cssText","length","shift","isString","v","String","elementOrSelector","ele","querySelector","Error","getOption","options","propName","def","value","getGutterSize","gutterSize","isFirst","isLast","gutterAlign","defaultGutterFn","i","gutterDirection","gut","className","defaultElementStyleFn","dim","size","gutSize","defaultGutterStyleFn","obj","Split","idsOption","ids","dimension","clientAxis","position","positionEnd","clientSize","elements","Array","from","firstElement","parent","parentNode","parentStyle","getComputedStyle","parentFlexDirection","flexDirection","sizes","map","minSize","minSizes","isArray","maxSize","Infinity","maxSizes","expandToMin","snapOffset","snapOffsets","dragInterval","direction","cursor","gutter","elementStyle","gutterStyle","setElementSize","Object","keys","forEach","prop","setGutterSize","gutterElement","getSizes","element","getMousePosition","e","touches","adjust","offset","a","b","percentage","drag","dragging","start","dragOffset","Math","round","call","calculateSizes","aBounds","bBounds","end","innerSize","computedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","trimToMin","sizesToTrim","parentSize","reduce","excessPixels","toSpare","pixelSizes","pixelSize","elementGutterSize","elementMinSize","push","newPixelSize","takenPixels","min","stopDragging","self","stop","move","userSelect","webkitUserSelect","MozUserSelect","pointerEvents","body","startDragging","button","preventDefault","bind","pairs","id","pair","temp","insertBefore","adjustToMin","computedSize","setSizes","newSizes","trimmed","newSize","destroy","preserveStyles","preserveGutter","removeChild","collapse"],"sources":["C:/Users/Le Roy/React Fundamentals/my-app/node_modules/split.js/dist/split.es.js"],"sourcesContent":["// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            snapOffset: snapOffsets[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\nexport default Split;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}