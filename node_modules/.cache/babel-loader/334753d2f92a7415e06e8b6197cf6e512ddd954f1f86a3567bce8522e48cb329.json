{"ast":null,"code":"'use strict';\n\n/**\n * Delay function calls only if they are not already ran async.\n *\n * @param {Function} fn Function that should be forced in async execution\n * @returns {Function} A wrapped function that will called the supplied callback.\n * @api public\n */\nmodule.exports = function hang(fn) {\n  var start = +new Date();\n\n  /**\n   * The wrapped function.\n   *\n   * @api private\n   */\n  function bro() {\n    var self = this;\n\n    //\n    // Time has passed since we've generated this function so we're going to\n    // assume that this function is already executed async.\n    //\n    if (+new Date() > start) {\n      return fn.apply(self, arguments);\n    }\n    for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {\n      args[i] = arguments[i];\n    }\n    (global.setImmediate || global.setTimeout)(function delay() {\n      fn.apply(self, args);\n      self = args = null;\n    }, 0);\n  }\n\n  //\n  // To make debugging more easy we want to use the name of the supplied\n  // function. So when you look at the functions that are assigned to event\n  // listeners you don't see a load of `onetime` functions but actually the\n  // names of the functions that this module will call.\n  //\n  bro.displayName = fn.displayName || fn.name || bro.displayName || bro.name;\n  return bro;\n};","map":{"version":3,"names":["module","exports","hang","fn","start","Date","bro","self","apply","arguments","i","l","length","args","Array","global","setImmediate","setTimeout","delay","displayName","name"],"sources":["C:/Users/Le Roy/node_modules/hang/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Delay function calls only if they are not already ran async.\n *\n * @param {Function} fn Function that should be forced in async execution\n * @returns {Function} A wrapped function that will called the supplied callback.\n * @api public\n */\nmodule.exports = function hang(fn) {\n  var start = +(new Date());\n\n  /**\n   * The wrapped function.\n   *\n   * @api private\n   */\n  function bro() {\n    var self = this;\n\n    //\n    // Time has passed since we've generated this function so we're going to\n    // assume that this function is already executed async.\n    //\n    if (+(new Date()) > start) {\n      return fn.apply(self, arguments);\n    }\n\n    for (var i = 0, l = arguments.length, args = new Array(l); i < l; i++) {\n      args[i] = arguments[i];\n    }\n\n    (global.setImmediate || global.setTimeout)(function delay() {\n      fn.apply(self, args);\n      self = args = null;\n    }, 0);\n  }\n\n  //\n  // To make debugging more easy we want to use the name of the supplied\n  // function. So when you look at the functions that are assigned to event\n  // listeners you don't see a load of `onetime` functions but actually the\n  // names of the functions that this module will call.\n  //\n  bro.displayName = fn.displayName || fn.name || bro.displayName || bro.name;\n\n  return bro;\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG,SAASC,IAAIA,CAACC,EAAE,EAAE;EACjC,IAAIC,KAAK,GAAG,CAAE,IAAIC,IAAI,EAAG;;EAEzB;AACF;AACA;AACA;AACA;EACE,SAASC,GAAGA,CAAA,EAAG;IACb,IAAIC,IAAI,GAAG,IAAI;;IAEf;IACA;IACA;IACA;IACA,IAAI,CAAE,IAAIF,IAAI,EAAG,GAAGD,KAAK,EAAE;MACzB,OAAOD,EAAE,CAACK,KAAK,CAACD,IAAI,EAAEE,SAAS,CAAC;IAClC;IAEA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACH,CAAC,CAAC,EAAED,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACrEG,IAAI,CAACH,CAAC,CAAC,GAAGD,SAAS,CAACC,CAAC,CAAC;IACxB;IAEA,CAACK,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,UAAU,EAAE,SAASC,KAAKA,CAAA,EAAG;MAC1Df,EAAE,CAACK,KAAK,CAACD,IAAI,EAAEM,IAAI,CAAC;MACpBN,IAAI,GAAGM,IAAI,GAAG,IAAI;IACpB,CAAC,EAAE,CAAC,CAAC;EACP;;EAEA;EACA;EACA;EACA;EACA;EACA;EACAP,GAAG,CAACa,WAAW,GAAGhB,EAAE,CAACgB,WAAW,IAAIhB,EAAE,CAACiB,IAAI,IAAId,GAAG,CAACa,WAAW,IAAIb,GAAG,CAACc,IAAI;EAE1E,OAAOd,GAAG;AACZ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}